<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secret Inventory Management System</title>
    <link rel="icon" type="image/x-icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==">

    <script>
        // Backup CDN loading function - MUST be defined before main ethers script
        function loadEthersFromBackup() {
            console.log('Primary CDN failed, trying backup CDNs...');

            const backupCDNs = [
                'https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js',
                'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js',
                'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js'
            ];

            let currentCDNIndex = 0;

            function tryNextCDN() {
                if (currentCDNIndex >= backupCDNs.length) {
                    console.error('All CDNs failed to load ethers.js');
                    // Show error message to user
                    setTimeout(() => {
                        const statusElement = document.getElementById('status-text');
                        if (statusElement) {
                            statusElement.innerHTML = '‚ùå Failed to load required libraries from all CDNs<br><small>Please check your internet connection and refresh the page</small>';
                        }
                    }, 100);
                    return;
                }

                const script = document.createElement('script');
                script.src = backupCDNs[currentCDNIndex];
                script.onload = function() {
                    console.log(`Ethers.js loaded successfully from backup CDN: ${backupCDNs[currentCDNIndex]}`);
                    // Verify ethers is now available
                    if (typeof window.ethers !== 'undefined') {
                        console.log('Ethers.js is now available on window object');
                        // Retry initialization after successful load
                        setTimeout(() => {
                            if (typeof window.ethereum !== 'undefined' && typeof initWithRetry === 'function') {
                                initWithRetry();
                            }
                        }, 1000);
                    } else {
                        console.error('Ethers.js loaded but not available on window object');
                    }
                };
                script.onerror = function() {
                    console.log(`Backup CDN ${currentCDNIndex + 1} failed: ${backupCDNs[currentCDNIndex]}`);
                    currentCDNIndex++;
                    tryNextCDN();
                };

                document.head.appendChild(script);
            }

            tryNextCDN();
        }
    </script>

    <!-- Ethers.js with multiple CDN fallbacks -->
    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"
            onload="console.log('Primary ethers CDN loaded successfully')"
            onerror="console.log('Primary ethers CDN failed, loading backup...'); loadEthersFromBackup()"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #7f8c8d;
            font-size: 1.2em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
        }

        .card h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .status-info {
            background: #d5f4e6;
            border: 2px solid #27ae60;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .status-info.error {
            background: #fdeaea;
            border-color: #e74c3c;
        }

        .status-info.success {
            background: #d5f4e6;
            border-color: #27ae60;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }

        .form-group select,
        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #bdc3c7;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .form-group select:focus,
        .form-group input:focus {
            outline: none;
            border-color: #3498db;
        }

        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(52, 152, 219, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn.danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .btn.success {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        .results-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            margin-top: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        }

        .inventory-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .inventory-item:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .item-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 1.2em;
        }

        .item-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
        }

        .status-active { background: #d5f4e6; color: #27ae60; }
        .status-low { background: #ffeaa7; color: #fdcb6e; }
        .status-inactive { background: #fdeaea; color: #e74c3c; }

        .item-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: #7f8c8d;
        }

        .quantity-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .quantity-btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .quantity-increase {
            background: #d5f4e6;
            color: #27ae60;
        }

        .quantity-increase:hover {
            background: #a9dfbf;
        }

        .quantity-decrease {
            background: #fdeaea;
            color: #e74c3c;
        }

        .quantity-decrease:hover {
            background: #fadbd8;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #dee2e6;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #3498db;
        }

        .stat-label {
            color: #7f8c8d;
            margin-top: 5px;
        }

        .audit-section {
            background: #ecf0f1;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .audit-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #bdc3c7;
        }

        .audit-item:last-child {
            border-bottom: none;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 2em;
            }

            .container {
                padding: 10px;
            }

            .item-details {
                grid-template-columns: 1fr;
            }
        }

        /* Status indicator styles */
        .status-info {
            padding: 10px 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: 500;
        }

        .status-info.success {
            background: #d5f4e6;
            color: #27ae60;
            border-left: 4px solid #27ae60;
        }

        .status-info.error {
            background: #fdeaea;
            color: #e74c3c;
            border-left: 4px solid #e74c3c;
        }

        .status-info.warning {
            background: #fef9e7;
            color: #f39c12;
            border-left: 4px solid #f39c12;
        }

        .status-info.info {
            background: #ebf3fd;
            color: #3498db;
            border-left: 4px solid #3498db;
        }

        /* Manager-only elements styling */
        .manager-only:disabled {
            opacity: 0.5 !important;
            cursor: not-allowed !important;
            background: #bdc3c7 !important;
            color: #7f8c8d !important;
        }

        /* Preset Lists Styling */
        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .preset-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #dee2e6;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .preset-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            border-color: #3498db;
        }

        .preset-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 15px;
        }

        .preset-icon {
            font-size: 2.5em;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.1));
        }

        .preset-title {
            font-size: 1.3em;
            font-weight: 700;
            color: #2c3e50;
            margin: 0;
        }

        .preset-description {
            color: #7f8c8d;
            font-size: 0.9em;
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .preset-items-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }

        .preset-item-tag {
            background: #3498db;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: 500;
        }

        .preset-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: #7f8c8d;
        }

        .deploy-btn {
            width: 100%;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
        }

        .deploy-btn:hover {
            background: linear-gradient(135deg, #2980b9 0%, #1f618d 100%);
            transform: translateY(-2px);
        }

        .deploy-btn:disabled {
            background: #bdc3c7 !important;
            cursor: not-allowed !important;
            transform: none !important;
        }

        /* Deployment Progress Styling */
        .deployment-progress {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60 0%, #2ecc71 100%);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        .progress-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .deployment-log {
            max-height: 200px;
            overflow-y: auto;
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 5px;
        }

        .log-success {
            color: #2ecc71;
        }

        .log-error {
            color: #e74c3c;
        }

        .log-info {
            color: #3498db;
        }

        /* Selected preset highlight */
        .preset-card.selected {
            border-color: #27ae60;
            background: linear-gradient(135deg, #d5f4e6 0%, #a9dfbf 100%);
        }

        .preset-card.deploying {
            border-color: #f39c12;
            background: linear-gradient(135deg, #fef9e7 0%, #fcf3cf 100%);
        }

        .preset-card.deployed {
            border-color: #27ae60;
            background: linear-gradient(135deg, #d5f4e6 0%, #a9dfbf 100%);
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê Secret Inventory Management System</h1>
            <p>Confidential Storage Management with Fully Homomorphic Encryption</p>
        </div>

        <div id="connection-status" class="status-info">
            <strong>Wallet Status:</strong> <span id="status-text">Connecting to wallet...</span>
            <div id="wallet-guide" style="margin-top: 15px; font-size: 0.9em; line-height: 1.4;">
                <p><strong>üìã Wallet Connection Guide:</strong></p>
                <ol style="margin: 10px 0; padding-left: 20px;">
                    <li>Install MetaMask browser extension if not already installed</li>
                    <li>Create or import a wallet account in MetaMask</li>
                    <li>Switch to <strong>Sepolia Test Network</strong> in MetaMask</li>
                    <li>Get free test ETH from <a href="https://sepoliafaucet.com/" target="_blank" style="color: #3498db;">Sepolia Faucet</a></li>
                    <li>Refresh this page and approve the connection request</li>
                </ol>
                <div id="network-info" style="margin-top: 10px; padding: 8px; background: rgba(52, 152, 219, 0.1); border-radius: 5px;">
                    <strong>üì° Network Requirements:</strong><br>
                    ‚Ä¢ Network: Sepolia Testnet<br>
                    ‚Ä¢ Chain ID: 11155111<br>
                    ‚Ä¢ Currency: SepoliaETH (Test ETH)
                </div>

                <div style="margin-top: 15px; text-align: center;">
                    <button id="connect-wallet-btn" onclick="connectWallet()"
                            style="background: #3498db; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 1em; font-weight: bold; display: none;">
                        üîó Connect Wallet Manually
                    </button>
                    <button id="refresh-connection-btn" onclick="refreshConnection()"
                            style="background: #e67e22; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 1em; font-weight: bold; margin-left: 10px; display: none;">
                        üîÑ Refresh Connection
                    </button>
                </div>
            </div>
        </div>

        <div class="main-content">

            <div class="card">
                <h2>Add Inventory Item</h2>
                <div class="form-group">
                    <label for="item-category">Storage Category:</label>
                    <select id="item-category">
                        <option value="">Select Category</option>
                        <option value="electronics">Electronics</option>
                        <option value="pharmaceuticals">Pharmaceuticals</option>
                        <option value="documents">Classified Documents</option>
                        <option value="chemicals">Chemical Compounds</option>
                        <option value="precious-metals">Precious Metals</option>
                        <option value="weapons">Security Equipment</option>
                        <option value="data-storage">Data Storage Devices</option>
                        <option value="biological">Biological Samples</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="item-name">Item Name:</label>
                    <input type="text" id="item-name" placeholder="Enter item identification code">
                </div>

                <div class="form-group">
                    <label for="item-description">Description:</label>
                    <input type="text" id="item-description" placeholder="Brief item description">
                </div>

                <div class="form-group">
                    <label for="initial-quantity">Initial Quantity:</label>
                    <input type="number" id="initial-quantity" placeholder="Starting quantity" min="0">
                </div>

                <div class="form-group">
                    <label for="min-threshold">Minimum Threshold:</label>
                    <input type="number" id="min-threshold" placeholder="Alert threshold" min="0">
                </div>

                <button class="btn manager-only" onclick="addInventoryItem()">Add Secret Item</button>
                <button class="btn" onclick="authorizeCurrentUser()" style="margin-top: 10px; background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);">Authorize as Manager</button>
            </div>

            <div class="card">
                <h2>Quantity Management</h2>
                <p>Update inventory levels with encrypted operations. All changes are secured using FHE technology.</p>
                <button class="btn" onclick="loadInventoryItems()">Load Inventory</button>

                <div style="margin-top: 20px;">
                    <div class="form-group">
                        <label for="update-amount">Adjustment Amount:</label>
                        <input type="number" id="update-amount" placeholder="Quantity to add/remove" min="1" value="1">
                    </div>
                </div>

                <div id="inventory-items"></div>
            </div>
        </div>

        <div class="results-section">
            <h2>Inventory Overview</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-number" id="total-items">0</div>
                    <div class="stat-label">Total Items</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="active-items">0</div>
                    <div class="stat-label">Active Items</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="low-stock-items">0</div>
                    <div class="stat-label">Low Stock Alerts</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="total-quantity">0</div>
                    <div class="stat-label">Total Quantity</div>
                </div>
            </div>

            <button class="btn manager-only" onclick="performAudit()" style="margin-top: 20px;">Perform Inventory Audit</button>
            <div id="audit-results" class="audit-section" style="display: none;"></div>

            <div id="inventory-results"></div>
        </div>
    </div>

    <script>
        // Ethers.js fallback loading system

        // Check if ethers is available
        function checkEthersAvailability() {
            return typeof window.ethers !== 'undefined';
        }

        // Contract configuration
        const CONTRACT_ADDRESS = "0x8ee4EE930Fdb29811fc44067b5c25807d4ce3613";
        const NETWORK_CONFIG = {
            chainId: "0xaa36a7", // Sepolia testnet (11155111 in decimal)
            chainName: "Sepolia Test Network",
            rpcUrls: ["https://sepolia.infura.io/v3/", "https://ethereum-sepolia.publicnode.com"],
            nativeCurrency: {
                name: "SepoliaETH",
                symbol: "ETH",
                decimals: 18
            },
            blockExplorerUrls: ["https://sepolia.etherscan.io/"]
        };

        // Contract ABI for SecretInventoryManagement (FHEVM-compatible)
        const CONTRACT_ABI = [
            {
                "inputs": [],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "uint256", "name": "itemId", "type": "uint256"},
                    {"indexed": false, "internalType": "string", "name": "itemName", "type": "string"},
                    {"indexed": false, "internalType": "string", "name": "category", "type": "string"},
                    {"indexed": false, "internalType": "address", "name": "owner", "type": "address"}
                ],
                "name": "ItemAdded",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "uint256", "name": "itemId", "type": "uint256"},
                    {"indexed": false, "internalType": "bool", "name": "isActive", "type": "bool"}
                ],
                "name": "ItemStatusUpdated",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "address", "name": "manager", "type": "address"}
                ],
                "name": "ManagerAuthorized",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "address", "name": "manager", "type": "address"}
                ],
                "name": "ManagerRevoked",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "internalType": "uint256", "name": "itemId", "type": "uint256"},
                    {"indexed": false, "internalType": "address", "name": "voter", "type": "address"}
                ],
                "name": "QuantityVoted",
                "type": "event"
            },
            {
                "inputs": [],
                "name": "APPROVAL_THRESHOLD",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "string", "name": "_itemName", "type": "string"},
                    {"internalType": "string", "name": "_category", "type": "string"},
                    {"internalType": "string", "name": "_description", "type": "string"},
                    {"internalType": "uint32", "name": "_initialQuantity", "type": "uint32"},
                    {"internalType": "uint32", "name": "_minThreshold", "type": "uint32"}
                ],
                "name": "addInventoryItem",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256[]", "name": "_itemIds", "type": "uint256[]"}],
                "name": "auditInventory",
                "outputs": [
                    {"internalType": "string[]", "name": "itemNames", "type": "string[]"},
                    {"internalType": "uint256[]", "name": "quantities", "type": "uint256[]"},
                    {"internalType": "bool[]", "name": "activeStatuses", "type": "bool[]"}
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "_manager", "type": "address"}],
                "name": "authorizeManager",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                "name": "authorizedManagers",
                "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "_itemId", "type": "uint256"}],
                "name": "getEncryptedQuantity",
                "outputs": [
                    {"internalType": "euint32", "name": "", "type": "bytes32"},
                    {"internalType": "euint32", "name": "", "type": "bytes32"}
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "_itemId", "type": "uint256"}],
                "name": "getItemDetails",
                "outputs": [
                    {"internalType": "string", "name": "itemName", "type": "string"},
                    {"internalType": "string", "name": "category", "type": "string"},
                    {"internalType": "string", "name": "description", "type": "string"},
                    {"internalType": "uint256", "name": "quantity", "type": "uint256"},
                    {"internalType": "uint256", "name": "minThreshold", "type": "uint256"},
                    {"internalType": "bool", "name": "isActive", "type": "bool"}
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "_itemId", "type": "uint256"}],
                "name": "getItemOwner",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "_itemId", "type": "uint256"}],
                "name": "getItemStatus",
                "outputs": [
                    {"internalType": "bool", "name": "isActive", "type": "bool"},
                    {"internalType": "bool", "name": "canView", "type": "bool"}
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "_itemId", "type": "uint256"}],
                "name": "getItemTimestamp",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getTotalItems",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256", "name": "_itemId", "type": "uint256"},
                    {"internalType": "address", "name": "_manager", "type": "address"}
                ],
                "name": "hasManagerVoted",
                "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "_manager", "type": "address"}],
                "name": "isAuthorizedManager",
                "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "_itemId", "type": "uint256"}],
                "name": "revealItem",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "_manager", "type": "address"}],
                "name": "revokeManager",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "totalItems",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256", "name": "_itemId", "type": "uint256"},
                    {"internalType": "bool", "name": "_isIncrease", "type": "bool"},
                    {"internalType": "uint32", "name": "_amount", "type": "uint32"}
                ],
                "name": "updateQuantity",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "name": "inventoryItems",
                "outputs": [
                    {"internalType": "string", "name": "itemName", "type": "string"},
                    {"internalType": "string", "name": "category", "type": "string"},
                    {"internalType": "string", "name": "description", "type": "string"},
                    {"internalType": "address", "name": "owner", "type": "address"},
                    {"internalType": "uint256", "name": "timestamp", "type": "uint256"},
                    {"internalType": "euint32", "name": "quantity", "type": "bytes32"},
                    {"internalType": "euint32", "name": "minThreshold", "type": "bytes32"},
                    {"internalType": "ebool", "name": "isActive", "type": "bytes32"},
                    {"internalType": "bool", "name": "isRevealed", "type": "bool"},
                    {"internalType": "uint256", "name": "lastUpdated", "type": "uint256"}
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256", "name": "", "type": "uint256"},
                    {"internalType": "address", "name": "", "type": "address"}
                ],
                "name": "hasVoted",
                "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        let provider, signer, contract;
        let currentAccount = null;
        let fhevmInstance = null;

        // FHEVM Configuration for Sepolia testnet
        const FHEVM_CONFIG = {
            network: "sepolia",
            chainId: 9000, // Sepolia testnet
            gatewayUrl: "https://gateway.sepolia.zama.ai/",
        };


        // Type definitions for TypeScript-style safety
        const ItemType = {
            itemName: "string",
            category: "string",
            description: "string",
            quantity: "uint256",
            minThreshold: "uint256",
            isActive: "bool"
        };

        // Initialize the application with FHEVM support
        async function init() {
            try {
                // Check if ethers.js is available
                if (!checkEthersAvailability()) {
                    console.error('Ethers.js is not available');
                    console.log('window.ethers:', typeof window.ethers);
                    console.log('Available window properties:', Object.keys(window).filter(k => k.includes('eth')));
                    updateStatus('‚ùå Ethers.js library not loaded. Please refresh the page.', 'error');
                    return;
                }

                console.log('‚úÖ Ethers.js is available:', typeof window.ethers);

                if (typeof window.ethereum !== 'undefined') {
                    updateStatus('Initializing Web3 provider...', 'info');
                    provider = new window.ethers.providers.Web3Provider(window.ethereum);

                    // Check and switch to Sepolia network if needed
                    updateStatus('Verifying network connection...', 'info');
                    await checkAndSwitchNetwork();

                    // Request account access
                    updateStatus('Requesting wallet access...', 'info');
                    await window.ethereum.request({ method: 'eth_requestAccounts' });

                    updateStatus('Establishing secure connection...', 'info');
                    signer = provider.getSigner();
                    currentAccount = await signer.getAddress();

                    // Initialize contract with proper error handling
                    updateStatus('Connecting to smart contract...', 'info');
                    contract = new window.ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

                    // Verify contract deployment
                    updateStatus('Verifying contract deployment...', 'info');
                    const contractCode = await provider.getCode(CONTRACT_ADDRESS);
                    if (contractCode === '0x') {
                        throw new Error('Contract not deployed at specified address');
                    }

                    updateStatus(`Connected to wallet: ${currentAccount.substring(0, 6)}...${currentAccount.substring(38)}`, 'success');

                    // Check if user is authorized manager with retry logic
                    await checkManagerAuthorization();

                    // Load initial data
                    await loadInventoryOverview();

                    // Setup event listeners for contract events
                    setupEventListeners();

                } else {
                    updateStatus('ü¶ä Please install MetaMask wallet to use this application', 'error');
                    showMetaMaskInstallPrompt();
                }
            } catch (error) {
                console.error('Initialization error:', error);
                updateStatus(`Connection failed: ${error.message}`, 'error');
            }
        }

        // Check and switch to Sepolia network
        async function checkAndSwitchNetwork() {
            const network = await provider.getNetwork();
            if (network.chainId !== 11155111) { // Sepolia chainId
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: '0xaa36a7' }], // Sepolia in hex
                    });
                } catch (switchError) {
                    // Network not added, add it
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [NETWORK_CONFIG],
                        });
                    } else {
                        throw switchError;
                    }
                }
            }
        }

        // Check manager authorization with proper error handling
        async function checkManagerAuthorization() {
            try {
                const isAuthorized = await contract.isAuthorizedManager(currentAccount);
                if (!isAuthorized) {
                    updateStatus('You are not an authorized inventory manager. Attempting to authorize...', 'warning');
                    // Try to authorize current user
                    await authorizeCurrentUser();
                } else {
                    updateStatus('Authorized manager connected', 'success');
                }
                return isAuthorized;
            } catch (error) {
                console.warn('Could not check authorization:', error);
                updateStatus('Could not verify manager status', 'warning');
                return false;
            }
        }

        // Authorize current user as manager
        async function authorizeCurrentUser() {
            try {
                updateStatus('Attempting to authorize current user as manager...', 'info');

                // Check if current user is contract owner first
                const tx = await contract.authorizeManager(currentAccount);
                updateStatus('Authorization transaction sent...', 'info');

                await tx.wait();
                updateStatus('Successfully authorized as manager!', 'success');

                // Re-check authorization
                await checkManagerAuthorization();

            } catch (error) {
                console.error('Authorization failed:', error);
                if (error.message.includes('Not authorized')) {
                    updateStatus('‚ö†Ô∏è Only contract owner can authorize managers. Please contact the contract owner.', 'warning');
                } else {
                    updateStatus(`Authorization failed: ${error.message}`, 'error');
                }
            }
        }

        // Setup event listeners for real-time updates
        function setupEventListeners() {
            try {
                // Listen for item additions
                contract.on('ItemAdded', (itemId, itemName, category, owner, event) => {
                    console.log('New item added:', { itemId: itemId.toString(), itemName, category, owner });
                    updateStatus(`New item added: ${itemName}`, 'success');
                    // Refresh inventory view
                    setTimeout(() => loadInventoryOverview(), 2000);
                });

                // Listen for quantity updates
                contract.on('QuantityVoted', (itemId, voter, event) => {
                    console.log('Quantity updated:', { itemId: itemId.toString(), voter });
                    updateStatus(`Inventory updated for item #${itemId}`, 'info');
                    // Refresh specific item view
                    setTimeout(() => loadInventoryOverview(), 2000);
                });

                // Listen for manager authorization changes
                contract.on('ManagerAuthorized', (manager, event) => {
                    console.log('Manager authorized:', manager);
                    if (manager.toLowerCase() === currentAccount.toLowerCase()) {
                        updateStatus('You have been authorized as a manager!', 'success');
                        location.reload(); // Refresh to enable manager features
                    }
                });

            } catch (error) {
                console.warn('Could not setup event listeners:', error);
            }
        }

        // Disable UI features for unauthorized users
        function disableManagerOnlyFeatures() {
            const managerElements = document.querySelectorAll('.manager-only');
            managerElements.forEach(element => {
                element.disabled = true;
                element.style.opacity = '0.5';
                element.title = 'Manager authorization required';
            });
        }

        function updateStatus(message, type = 'info') {
            const statusElement = document.getElementById('connection-status');
            const statusText = document.getElementById('status-text');
            const walletGuide = document.getElementById('wallet-guide');

            statusText.textContent = message;
            statusElement.className = `status-info ${type}`;

            // Show detailed wallet guide only when there are connection issues
            if (type === 'error' || type === 'warning' || message.includes('Connecting')) {
                walletGuide.style.display = 'block';
            } else if (type === 'success' || message.includes('Connected')) {
                walletGuide.style.display = 'none';
            }

            // Add detailed connection stage information
            if (message.includes('Connecting')) {
                statusText.innerHTML = `
                    ${message}<br>
                    <small style="opacity: 0.7;">Detecting MetaMask wallet and requesting connection...</small>
                `;
            } else if (message.includes('Connected')) {
                statusText.innerHTML = `
                    ‚úÖ ${message}<br>
                    <small style="opacity: 0.7;">Ready for secure inventory management operations</small>
                `;
            }

            // Show/hide manual connection buttons based on status
            const connectBtn = document.getElementById('connect-wallet-btn');
            const refreshBtn = document.getElementById('refresh-connection-btn');

            if (connectBtn && refreshBtn) {
                if (type === 'error' || type === 'warning') {
                    connectBtn.style.display = 'inline-block';
                    refreshBtn.style.display = 'inline-block';
                } else if (type === 'success') {
                    connectBtn.style.display = 'none';
                    refreshBtn.style.display = 'none';
                }
            }
        }

        // Manual wallet connection function
        async function connectWallet() {
            try {
                updateStatus('Attempting manual wallet connection...', 'info');
                networkRetryCount = 0; // Reset retry counter
                await initWithRetry();
            } catch (error) {
                updateStatus('Manual connection failed - ' + error.message, 'error');
                console.error('Manual connection error:', error);
            }
        }

        // Refresh connection function
        function refreshConnection() {
            updateStatus('Refreshing connection...', 'info');
            networkRetryCount = 0; // Reset retry counter
            window.location.reload();
        }

        // Enhanced addInventoryItem with type safety and FHEVM-compatible error handling
        async function addInventoryItem() {
            try {
                // Type-safe input validation
                const inputs = validateInventoryInputs();
                if (!inputs) return;

                const { category, itemName, description, initialQuantity, minThreshold } = inputs;

                updateStatus('Adding item to secret inventory...', 'info');

                // Disable form during transaction
                toggleFormState(false);

                // Convert to proper uint32 types for FHEVM compatibility
                const quantityUint32 = window.ethers.BigNumber.from(initialQuantity);
                const thresholdUint32 = window.ethers.BigNumber.from(minThreshold);

                // Validate ranges for uint32
                if (quantityUint32.gt(window.ethers.BigNumber.from("4294967295")) ||
                    thresholdUint32.gt(window.ethers.BigNumber.from("4294967295"))) {
                    throw new Error('Values too large for uint32 (max: 4,294,967,295)');
                }

                // Execute transaction with manual gas limit (similar to case/fheguess approach)
                let gasLimit = 300000; // Start with a reasonable default
                let gasPrice = null;

                try {
                    // Try to estimate gas first
                    const gasEstimate = await contract.estimateGas.addInventoryItem(
                        itemName,
                        category,
                        description,
                        quantityUint32,
                        thresholdUint32
                    );
                    gasLimit = gasEstimate.mul(130).div(100); // 30% buffer
                    gasPrice = await provider.getGasPrice();
                } catch (estimateError) {
                    console.warn('Gas estimation failed, using manual limit:', estimateError);
                    gasLimit = 500000; // Higher manual limit for FHE operations
                    gasPrice = await provider.getGasPrice();
                }

                const tx = await contract.addInventoryItem(
                    itemName,
                    category,
                    description,
                    quantityUint32,
                    thresholdUint32,
                    {
                        gasLimit: gasLimit,
                        gasPrice: gasPrice
                    }
                );

                updateStatus(`Transaction sent: ${tx.hash.substring(0, 10)}...`, 'info');

                // Wait for confirmation with timeout
                const receipt = await Promise.race([
                    tx.wait(),
                    new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('Transaction timeout')), 60000)
                    )
                ]);

                if (receipt.status === 1) {
                    updateStatus('Item added to secret inventory successfully!', 'success');

                    // Extract item ID from events
                    const itemAddedEvent = receipt.events?.find(event => event.event === 'ItemAdded');
                    if (itemAddedEvent) {
                        const itemId = itemAddedEvent.args.itemId.toString();
                        console.log(`New item ID: ${itemId}`);
                    }
                } else {
                    throw new Error('Transaction failed');
                }

                // Clear form
                clearInventoryForm();

                // Reload inventory
                await loadInventoryOverview();

            } catch (error) {
                console.error('Add item error:', error);
                updateStatus(`Failed to add item: ${error.message}`, 'error');
            } finally {
                toggleFormState(true);
            }
        }

        // Type-safe input validation with proper error messages
        function validateInventoryInputs() {
            const category = document.getElementById('item-category').value.trim();
            const itemName = document.getElementById('item-name').value.trim();
            const description = document.getElementById('item-description').value.trim();
            const initialQuantity = document.getElementById('initial-quantity').value.trim();
            const minThreshold = document.getElementById('min-threshold').value.trim();

            // Required field validation
            if (!category || !itemName || !description || !initialQuantity || !minThreshold) {
                updateStatus('Please fill in all required fields', 'error');
                return null;
            }

            // Type validation for numbers
            const quantity = parseInt(initialQuantity);
            const threshold = parseInt(minThreshold);

            if (isNaN(quantity) || quantity < 0) {
                updateStatus('Initial quantity must be a non-negative number', 'error');
                return null;
            }

            if (isNaN(threshold) || threshold < 0) {
                updateStatus('Minimum threshold must be a non-negative number', 'error');
                return null;
            }

            // Business logic validation
            if (threshold > quantity) {
                updateStatus('Minimum threshold cannot exceed initial quantity', 'error');
                return null;
            }

            // String length validation
            if (itemName.length > 100) {
                updateStatus('Item name too long (max 100 characters)', 'error');
                return null;
            }

            if (description.length > 500) {
                updateStatus('Description too long (max 500 characters)', 'error');
                return null;
            }

            return {
                category,
                itemName,
                description,
                initialQuantity: quantity,
                minThreshold: threshold
            };
        }

        // Toggle form state during transactions
        function toggleFormState(enabled) {
            const formElements = [
                'item-category',
                'item-name',
                'item-description',
                'initial-quantity',
                'min-threshold'
            ];

            formElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.disabled = !enabled;
                }
            });

            // Also toggle submit button
            const submitButton = document.querySelector('.manager-only[onclick="addInventoryItem()"]');
            if (submitButton) {
                submitButton.disabled = !enabled;
                submitButton.textContent = enabled ? 'Add Secret Item' : 'Processing...';
            }
        }

        // Clear inventory form
        function clearInventoryForm() {
            document.getElementById('item-category').value = '';
            document.getElementById('item-name').value = '';
            document.getElementById('item-description').value = '';
            document.getElementById('initial-quantity').value = '';
            document.getElementById('min-threshold').value = '';
        }

        async function loadInventoryItems() {
            try {
                updateStatus('Loading inventory items...', 'info');

                const totalItems = await contract.getTotalItems();
                const inventoryContainer = document.getElementById('inventory-items');
                inventoryContainer.innerHTML = '';

                if (totalItems.isZero()) {
                    inventoryContainer.innerHTML = '<p>No inventory items found.</p>';
                    updateStatus('No inventory items to display', 'info');
                    return;
                }

                for (let i = 0; i < totalItems; i++) {
                    try {
                        const [itemName, category, description, quantity, minThreshold, isActive] = await contract.getItemDetails(i);

                        const itemElement = createInventoryItemElement(i, itemName, category, description, quantity, minThreshold, isActive);
                        inventoryContainer.appendChild(itemElement);
                    } catch (error) {
                        console.error(`Error loading item ${i}:`, error);
                    }
                }

                updateStatus(`Loaded ${totalItems} inventory items`, 'success');

            } catch (error) {
                console.error('Load inventory error:', error);
                updateStatus(`Failed to load inventory: ${error.message}`, 'error');
            }
        }

        function createInventoryItemElement(itemId, itemName, category, description, quantity, minThreshold, isActive) {
            const div = document.createElement('div');
            div.className = 'inventory-item';

            const statusClass = !isActive ? 'status-inactive' : (quantity <= minThreshold ? 'status-low' : 'status-active');
            const statusText = !isActive ? 'Inactive' : (quantity <= minThreshold ? 'Low Stock' : 'Active');

            div.innerHTML = `
                <div class="item-header">
                    <div class="item-title">${itemName}</div>
                    <div class="item-status ${statusClass}">${statusText}</div>
                </div>
                <div class="item-details">
                    <div><strong>Category:</strong> ${category}</div>
                    <div><strong>Quantity:</strong> ${quantity}</div>
                    <div><strong>Description:</strong> ${description}</div>
                    <div><strong>Min Threshold:</strong> ${minThreshold}</div>
                </div>
                <div class="quantity-controls">
                    <button class="quantity-btn quantity-increase" onclick="updateItemQuantity(${itemId}, true)">
                        ‚ûï Increase Stock
                    </button>
                    <button class="quantity-btn quantity-decrease" onclick="updateItemQuantity(${itemId}, false)">
                        ‚ûñ Decrease Stock
                    </button>
                </div>
            `;
            return div;
        }

        async function updateItemQuantity(itemId, isIncrease) {
            try {
                const amount = document.getElementById('update-amount').value;
                if (!amount || amount < 1) {
                    alert('Please enter a valid amount');
                    return;
                }

                updateStatus(`${isIncrease ? 'Increasing' : 'Decreasing'} quantity for item #${itemId}...`, 'info');

                // Frontend sends plain boolean, contract will encrypt it using FHE.asBool()
                const tx = await contract.updateQuantity(itemId, isIncrease, parseInt(amount));
                await tx.wait();

                updateStatus('Quantity updated successfully! (Encrypted with FHE)', 'success');

                // Reload inventory
                await loadInventoryItems();
                await loadInventoryOverview();

            } catch (error) {
                console.error('Update quantity error:', error);
                updateStatus(`Update failed: ${error.message}`, 'error');
            }
        }

        async function loadInventoryOverview() {
            try {
                const totalItems = await contract.getTotalItems();
                const resultsContainer = document.getElementById('inventory-results');
                resultsContainer.innerHTML = '';

                let activeCount = 0;
                let lowStockCount = 0;
                let totalQuantity = 0;

                for (let i = 0; i < totalItems; i++) {
                    try {
                        const [itemName, category, description, quantity, minThreshold, isActive] = await contract.getItemDetails(i);

                        if (isActive) activeCount++;
                        if (quantity <= minThreshold) lowStockCount++;
                        totalQuantity += parseInt(quantity);

                        const statusClass = !isActive ? 'status-inactive' : (quantity <= minThreshold ? 'status-low' : 'status-active');
                        const statusText = !isActive ? 'Inactive' : (quantity <= minThreshold ? 'Low Stock' : 'Active');

                        const itemElement = document.createElement('div');
                        itemElement.className = 'inventory-item';
                        itemElement.innerHTML = `
                            <div class="item-header">
                                <div class="item-title">${itemName}</div>
                                <div class="item-status ${statusClass}">${statusText}</div>
                            </div>
                            <div class="item-details">
                                <div><strong>Category:</strong> ${category}</div>
                                <div><strong>Quantity:</strong> ${quantity}</div>
                                <div><strong>Description:</strong> ${description}</div>
                                <div><strong>Min Threshold:</strong> ${minThreshold}</div>
                            </div>
                        `;
                        resultsContainer.appendChild(itemElement);
                    } catch (error) {
                        console.error(`Error loading item ${i}:`, error);
                    }
                }

                // Update statistics
                document.getElementById('total-items').textContent = totalItems.toString();
                document.getElementById('active-items').textContent = activeCount.toString();
                document.getElementById('low-stock-items').textContent = lowStockCount.toString();
                document.getElementById('total-quantity').textContent = totalQuantity.toString();

            } catch (error) {
                console.error('Load overview error:', error);
                updateStatus(`Failed to load overview: ${error.message}`, 'error');
            }
        }

        async function performAudit() {
            try {
                updateStatus('Performing inventory audit...', 'info');

                const totalItems = await contract.getTotalItems();
                if (totalItems.isZero()) {
                    alert('No items to audit');
                    return;
                }

                // Create array of all item IDs
                const itemIds = [];
                for (let i = 0; i < totalItems; i++) {
                    itemIds.push(i);
                }

                const [itemNames, quantities, activeStatuses] = await contract.auditInventory(itemIds);

                const auditContainer = document.getElementById('audit-results');
                auditContainer.innerHTML = '<h3>Audit Results</h3>';

                for (let i = 0; i < itemNames.length; i++) {
                    const auditItem = document.createElement('div');
                    auditItem.className = 'audit-item';
                    auditItem.innerHTML = `
                        <span><strong>Item #${i}:</strong> ${itemNames[i]}</span>
                        <span>Qty: ${quantities[i]} | Status: ${activeStatuses[i] ? 'Active' : 'Inactive'}</span>
                    `;
                    auditContainer.appendChild(auditItem);
                }

                auditContainer.style.display = 'block';
                updateStatus('Audit completed successfully!', 'success');

            } catch (error) {
                console.error('Audit error:', error);
                updateStatus(`Audit failed: ${error.message}`, 'error');
            }
        }

        // Enhanced updateQuantity function with FHEVM-compatible error handling
        async function updateQuantity(itemId, isIncrease, amount) {
            try {
                // Validate inputs
                if (!itemId && itemId !== 0) {
                    throw new Error('Invalid item ID');
                }

                const numAmount = parseInt(amount);
                if (isNaN(numAmount) || numAmount <= 0) {
                    throw new Error('Amount must be a positive number');
                }

                if (numAmount > 4294967295) {
                    throw new Error('Amount too large for uint32 (max: 4,294,967,295)');
                }

                updateStatus(`${isIncrease ? 'Increasing' : 'Decreasing'} quantity for item #${itemId}...`, 'info');

                // Check if user has already voted
                const hasVoted = await contract.hasManagerVoted(itemId, currentAccount);
                if (hasVoted) {
                    throw new Error('You have already voted on this item update');
                }

                // Execute with manual gas limit approach
                let gasLimit = 250000; // Start with reasonable default for updates
                let gasPrice = null;

                try {
                    // Try to estimate gas first
                    const gasEstimate = await contract.estimateGas.updateQuantity(
                        itemId,
                        isIncrease,
                        numAmount
                    );
                    gasLimit = gasEstimate.mul(130).div(100); // 30% buffer
                    gasPrice = await provider.getGasPrice();
                } catch (estimateError) {
                    console.warn('Gas estimation failed for update, using manual limit:', estimateError);
                    gasLimit = 400000; // Higher manual limit for FHE operations
                    gasPrice = await provider.getGasPrice();
                }

                // Frontend sends plain boolean, contract will encrypt it using FHE.asBool()
                const tx = await contract.updateQuantity(
                    itemId,
                    isIncrease,
                    numAmount,
                    {
                        gasLimit: gasLimit,
                        gasPrice: gasPrice
                    }
                );

                updateStatus(`Transaction sent: ${tx.hash.substring(0, 10)}...`, 'info');

                const receipt = await tx.wait();

                if (receipt.status === 1) {
                    updateStatus('Quantity updated successfully! (Encrypted with FHE)', 'success');

                    // Reload inventory views
                    await Promise.all([
                        loadInventoryItems(),
                        loadInventoryOverview()
                    ]);
                } else {
                    throw new Error('Transaction failed');
                }

            } catch (error) {
                console.error('Update quantity error:', error);

                // Parse specific error messages
                let errorMessage = error.message;
                if (error.reason) {
                    errorMessage = error.reason;
                } else if (error.data?.message) {
                    errorMessage = error.data.message;
                }

                updateStatus(`Update failed: ${errorMessage}`, 'error');
            }
        }

        // Enhanced function to reveal item (decrypt for viewing)
        async function revealItem(itemId) {
            try {
                if (!itemId && itemId !== 0) {
                    throw new Error('Invalid item ID');
                }

                updateStatus(`Revealing item #${itemId} data...`, 'info');

                const tx = await contract.revealItem(itemId);
                updateStatus(`Transaction sent: ${tx.hash.substring(0, 10)}...`, 'info');

                const receipt = await tx.wait();

                if (receipt.status === 1) {
                    updateStatus('Item revealed successfully! Encrypted data is now viewable.', 'success');

                    // Reload to show decrypted values
                    await Promise.all([
                        loadInventoryItems(),
                        loadInventoryOverview()
                    ]);
                } else {
                    throw new Error('Transaction failed');
                }

            } catch (error) {
                console.error('Reveal item error:', error);
                updateStatus(`Reveal failed: ${error.message}`, 'error');
            }
        }

        // Enhanced function to authorize new manager
        async function authorizeManager(managerAddress) {
            try {
                if (!window.ethers.utils.isAddress(managerAddress)) {
                    throw new Error('Invalid Ethereum address');
                }

                updateStatus(`Authorizing manager: ${managerAddress}...`, 'info');

                const tx = await contract.authorizeManager(managerAddress);
                updateStatus(`Transaction sent: ${tx.hash.substring(0, 10)}...`, 'info');

                const receipt = await tx.wait();

                if (receipt.status === 1) {
                    updateStatus('Manager authorized successfully!', 'success');
                } else {
                    throw new Error('Transaction failed');
                }

            } catch (error) {
                console.error('Authorize manager error:', error);
                updateStatus(`Authorization failed: ${error.message}`, 'error');
            }
        }

        // Function to check if current user can view encrypted data
        async function checkViewAccess(itemId) {
            try {
                const [isActive, canView] = await contract.getItemStatus(itemId);
                return { isActive, canView };
            } catch (error) {
                console.warn('Could not check view access:', error);
                return { isActive: false, canView: false };
            }
        }


        // Show MetaMask installation prompt
        function showMetaMaskInstallPrompt() {
            const promptDiv = document.createElement('div');
            promptDiv.innerHTML = `
                <div style="background: #f39c12; color: white; padding: 20px; text-align: center; font-family: Arial, sans-serif; margin: 20px; border-radius: 10px;">
                    <h3>ü¶ä MetaMask Wallet Required</h3>
                    <p>This application requires MetaMask to connect to Ethereum blockchain</p>
                    <div style="margin-top: 15px;">
                        <a href="https://metamask.io/download/" target="_blank"
                           style="background: white; color: #f39c12; text-decoration: none; padding: 10px 20px; border-radius: 5px; font-weight: bold; margin: 0 10px;">
                            üì• Download MetaMask
                        </a>
                        <button onclick="location.reload()"
                                style="background: #e67e22; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 0 10px;">
                            üîÑ Installed, Refresh Page
                        </button>
                    </div>
                </div>
            `;

            const container = document.querySelector('.container');
            if (container) {
                container.insertBefore(promptDiv, container.firstChild);
            }
        }

        // Enhanced error handling for initialization
        function handleInitError(error) {
            let errorMessage = 'Initialization failed';
            let errorType = 'error';

            if (error.message.includes('Network Error') || error.message.includes('fetch')) {
                errorMessage = 'Network connection failed, please check your network connection';
                errorType = 'warning';
            } else if (error.message.includes('rejected')) {
                errorMessage = 'User rejected wallet connection request';
                errorType = 'warning';
            } else if (error.message.includes('chain')) {
                errorMessage = 'Please switch to Sepolia test network';
                errorType = 'warning';
            }

            updateStatus(errorMessage, errorType);
            console.error('Detailed error information:', error);
        }

        // Enhanced network detection and auto-retry
        let networkRetryCount = 0;
        const MAX_NETWORK_RETRIES = 3;

        async function initWithRetry() {
            try {
                await init();
            } catch (error) {
                if (networkRetryCount < MAX_NETWORK_RETRIES &&
                    (error.message.includes('Network') || error.message.includes('fetch'))) {
                    networkRetryCount++;
                    updateStatus(`Network connection failed, retrying (${networkRetryCount}/${MAX_NETWORK_RETRIES})...`, 'warning');
                    setTimeout(initWithRetry, 2000 * networkRetryCount); // Exponential backoff
                } else {
                    handleInitError(error);
                }
            }
        }

        // Wait for ethers to be available before initializing
        function waitForEthers() {
            if (typeof window.ethers !== 'undefined') {
                console.log('‚úÖ Ethers.js detected, initializing...');
                setTimeout(initWithRetry, 500);
            } else {
                console.log('‚è≥ Waiting for ethers.js to load...');
                setTimeout(waitForEthers, 500);
            }
        }

        // Initialize when page loads with retry mechanism
        window.addEventListener('load', function() {
            // Wait for ethers to be available
            waitForEthers();
        });

        // Enhanced MetaMask event handlers
        if (window.ethereum) {
            // Handle account changes with better user feedback
            window.ethereum.on('accountsChanged', function (accounts) {
                console.log('Account changed:', accounts);
                if (accounts.length === 0) {
                    updateStatus('‚ùå Wallet disconnected - Please reconnect to MetaMask', 'error');
                    contract = null;
                    signer = null;
                    currentAccount = null;
                } else {
                    updateStatus('üîÑ Account changed - Reconnecting...', 'info');
                    // Reset retry counter for new account
                    networkRetryCount = 0;
                    setTimeout(initWithRetry, 1000);
                }
            });

            // Handle network changes with user guidance
            window.ethereum.on('chainChanged', function (chainId) {
                console.log('Network changed to:', chainId);
                const sepoliaChainId = '0xaa36a7'; // Sepolia testnet chain ID in hex

                if (chainId === sepoliaChainId) {
                    updateStatus('‚úÖ Connected to Sepolia network - Reloading...', 'success');
                    setTimeout(() => window.location.reload(), 1500);
                } else {
                    updateStatus('‚ö†Ô∏è Wrong network detected - Please switch to Sepolia testnet', 'warning');
                    setTimeout(() => window.location.reload(), 2000);
                }
            });

            // Handle connection events
            window.ethereum.on('connect', function (connectInfo) {
                console.log('MetaMask connected:', connectInfo);
                updateStatus('üîó MetaMask connection established', 'success');
            });

            // Handle disconnection events
            window.ethereum.on('disconnect', function (error) {
                console.log('MetaMask disconnected:', error);
                updateStatus('üîå MetaMask disconnected - Please refresh and reconnect', 'error');
                contract = null;
                signer = null;
                currentAccount = null;
            });
        } else {
            // No MetaMask detected - show installation guide
            updateStatus('ü¶ä MetaMask not detected', 'error');
            showMetaMaskInstallPrompt();
        }
    </script>
</body>
</html>